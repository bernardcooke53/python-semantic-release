"""Helpers to read settings from setup.cfg or pyproject.toml
"""
from __future__ import annotations
import configparser
import importlib
import logging
import os
from collections import ChainMap
from dataclasses import dataclass, fields
from os import getcwd
from typing import Callable, List, Union, Dict, Any, Optional, Tuple

import tomlkit
from tomlkit.exceptions import TOMLKitError

from .errors import ImproperConfigurationError

logger = logging.getLogger(__name__)


@dataclass
class Config:
    commit_version_number: Optional[bool] = None

    parser_angular_allowed_types: str = (
        "build,chore,ci,docs,feat,fix,perf,style,refactor,test"
    )
    parser_angular_default_level_bump: str = "no-release"
    # valid options: no-release, patch, minor, major
    parser_angular_minor_types: str = "feat"
    parser_angular_patch_types: str = "fix,perf"
    branch: str = "master"
    build_command: str = "python setup.py sdist bdist_wheel"
    changelog_capitalize: bool = True
    changelog_components: str = "semantic_release.changelog.changelog_headers"
    changelog_file: str = "CHANGELOG.md"
    changelog_placeholder: str = "<!--next-version-placeholder-->"
    changelog_scope: bool = True
    changelog_sections: str = "feature,fix,breaking,documentation,performance,:boom:,:sparkles:,:children_crossing:,:lipstick:,:iphone:,:egg:,:chart_with_upwards_trend:,:ambulance:,:lock:,:bug:,:zap:,:goal_net:,:alien:,:wheelchair:,:speech_balloon:,:mag:,:apple:,:penguin:,:checkered_flag:,:robot:,:green_apple:,Other"
    check_build_status: bool = False
    include_additional_files: str = ""
    commit_author: str = "semantic-release <semantic-release>"
    commit_message: str = "Automatically generated by python-semantic-release"
    commit_parser: str = "semantic_release.history.angular_parser"
    commit_subject: str = "{version}"
    dist_path: str = "dist"
    dist_glob_patterns: str = "*"
    fix_tag: str = ":nut_and_bolt:"
    github_token_var: str = "GH_TOKEN"
    gitlab_token_var: str = "GL_TOKEN"
    gitea_token_var: str = "GITEA_TOKEN"

    hvcs: str = "github"
    hvcs_domain: str = ""
    hvcs_api_domain: str = ""
    ignore_token_for_push: bool = False
    major_emoji: str = ":boom:"
    major_on_zero: bool = True
    minor_emoji: str = ":sparkles:,:children_crossing:,:lipstick:,:iphone:,:egg:,:chart_with_upwards_trend:"
    minor_tag: str = ":sparkles:"
    patch_emoji: str = ":ambulance:,:lock:,:bug:,:zap:,:goal_net:,:alien:,:wheelchair:,:speech_balloon:,:mag:,:apple:,:penguin:,:checkered_flag:,:robot:,:green_apple:"
    patch_without_tag: bool = False
    pre_commit_command: str = ""
    prerelease_tag: str = "beta"
    pypi_pass_var: str = "PYPI_PASSWORD"
    pypi_token_var: str = "PYPI_TOKEN"
    pypi_user_var: str = "PYPI_USERNAME"
    repository: str = "pypi"
    repository_user_var: str = "REPOSITORY_USERNAME"
    repository_pass_var: str = "REPOSITORY_PASSWORD"
    # repository_url doesn't seem to be in defaults.cfg yet is a documented option
    repository_url: str = ""
    repository_url_var: str = "REPOSITORY_URL"
    remove_dist: bool = True
    scipy_parser: str = "semantic_release.history.parser_scipy"
    tag_commit: bool = True
    tag_format: str = "v{version}"
    upload_to_repository: bool = True
    upload_to_pypi: bool = True
    upload_to_pypi_glob_patterns: str = "*"
    upload_to_release: bool = True
    version_pattern: str = ""
    version_source: str = "commit"
    version_variable: Union[str, List[str]] = ""
    version_toml: str = ""

    def __post_init__(self) -> None:
        if self.commit_version_number is None:
            self.commit_version_number = self.version_source == "tag"

    @classmethod
    def from_files(cls, **cli_options: Any) -> Config:
        cwd = getcwd()
        ini_paths = [
            os.path.join(os.path.dirname(__file__), "defaults.cfg"),
            os.path.join(cwd, "setup.cfg"),
        ]
        ini_config = cls._config_from_ini(ini_paths)

        toml_path = os.path.join(cwd, "pyproject.toml")
        toml_config = cls._config_from_pyproject(toml_path)

        return Config(**ChainMap(cli_options, toml_config, ini_config))

    @classmethod
    def with_additional_kwargs(cls, **kwargs: Any) -> Tuple[Config, Dict[str, Any]]:
        init_kwargs = {}
        for field in fields(cls):
            if field.name in kwargs:
                init_kwargs[field.name] = kwargs.pop(field.name)
        return cls.from_files(**init_kwargs), kwargs

    @staticmethod
    def _config_from_ini(paths: List[str]) -> Dict[str, Any]:
        parser = configparser.ConfigParser()
        parser.read(paths)

        flags = frozenset(
            (
                "changelog_capitalize",
                "changelog_scope",
                "check_build_status",
                "commit_version_number",
                "ignore_token_for_push",
                "patch_without_tag",
                "major_on_zero",
                "remove_dist",
                "upload_to_pypi",
                "upload_to_repository",
                "upload_to_release",
                "tag_commit",
            )
        )

        # Iterate through the sections so that default values are applied
        # correctly.  See:
        # https://stackoverflow.com/questions/1773793/convert-configparser-items-to-dictionary
        config = {
            key: (
                parser.getboolean("semantic_release", key)
                if key in flags
                else parser.get("semantic_release", key)
            )
            for key, _ in parser.items("semantic_release")
        }

        return config

    @staticmethod
    def _config_from_pyproject(path):
        if os.path.isfile(path):
            try:
                with open(path, "r") as f:
                    pyproject = tomlkit.loads(f.read())
                if pyproject:
                    return pyproject.get("tool", {}).get("semantic_release", {})
            except TOMLKitError as e:
                logger.warning(f"Could not decode pyproject.toml: {e}")

        return {}


def get_commit_parser(config: Config) -> Callable:
    """Get the currently-configured commit parser

    :raises ImproperConfigurationError: if ImportError or AttributeError is raised
    :returns: Commit parser
    """

    try:
        # All except the last part is the import path
        parts = config.commit_parser.split(".")
        module = ".".join(parts[:-1])
        # The final part is the name of the parse function
        parser = getattr(importlib.import_module(module), parts[-1])

        # TODO: this is a massive hack to keep things semi-similar, will be removed
        parser_module = parser.__module__
        if parser_module == "semantic_release.history.parser_angular":
            parser_opts = (
                config.parser_angular_allowed_types,
                config.parser_angular_minor_types,
                config.parser_angular_patch_types,
                config.parser_angular_default_level_bump,
            )
        elif parser_module == "semantic_release.history.parser_emoji":
            parser_opts = (config.major_emoji, config.minor_emoji, config.patch_emoji)
        elif parser_module == "semantic_release.history.parser_tag":
            parser_opts = (config.minor_tag, config.fix_tag)
        elif parser_module == "semantic_release.history.parser_scipy":
            parser_opts = ()

        return lambda message: parser(message, *parser_opts)
    except (ImportError, AttributeError) as error:
        raise ImproperConfigurationError(f'Unable to import parser "{error}"')


def current_changelog_components(changelog_components: str) -> List[Callable]:
    """Get the currently-configured changelog components

    :raises ImproperConfigurationError: if ImportError or AttributeError is raised
    :returns: List of component functions
    """
    component_paths = changelog_components.split(",")
    components = []

    for path in component_paths:
        try:
            # All except the last part is the import path
            parts = path.split(".")
            module = ".".join(parts[:-1])
            # The final part is the name of the component function
            components.append(getattr(importlib.import_module(module), parts[-1]))
        except (ImportError, AttributeError) as error:
            raise ImproperConfigurationError(
                f'Unable to import changelog component "{path}"'
            )

    return components
